---
title: "オープン・クローズドの原則(OCP)"
weight: 2
bookToc: true
---

# オープン・クローズドの原則(The Open Closed Principle)

## オープン・クローズドの原則(OCP)とはなにか？

オープン・クローズドの原則(OCP)とは
**ソフトウェアの構成要素(クラス、モジュール、関数など)は拡張に対して開いて(オープン)いて、修正に対しては閉じて(クローズド)いなければならない**
という原則です。

「硬い」設計にしてしまうと、プログラムのちょっとした変更でさえ、その箇所と依存関係を持つすべてのモジュールに影響を与えてしまいます。
オープン・クローズドの原則を適用することで、そうした修正の影響範囲を小さくできます。

オープン・クローズドの原則に従って設計されたモジュールには次のような特徴があります。

1. **拡張に対して開かれている**  
これはモジュールの振る舞いを拡張できるという意味です。
アプリケーションの仕様変更があったとしても、モジュールに新たな振る舞いを追加することでその変更に対処できるようにします。
つまり、そのモジュールの変更内容を自由に変更できるということです。

2. **修正に対して閉じている**  
モジュールの振る舞いを変更しても、そのモジュールのソースコードやバイナリコードはまったく影響を受けない。
すでにモジュールがコンパイルされてバイナリ形式になっているものは、それがリンクライブラリであれ、DLLであれ手を触れる必要はないということです。

一見この2つの特徴は矛盾しているように見えます。
通常モジュールの振る舞いを拡張するにはそのモジュールのソースコード自体を変更しなければなりません。
また、ソースコードを変更しなければそのモジュールの振る舞いを変更できないと思うのが普通だと思います。

ではどうしたら、ソースコードを変更せずにモジュールの振る舞いを変えることができるでしょうか？

## 『抽象』に依存しろ

C++やJavaのようなオブジェクト指向言語は宣言が固定されていても、それが特定の実装に結合していないメソッドを「抽象」を使って表現できます。
これらの言語では「抽象」は抽象基本クラスを使って記述され、特定の実装に結合していないメソッドはその派生クラスで実装されます。

モジュールの設計ではこういった「抽象」のメカニズムを利用することが有効です。
モジュールをある固定した「抽象」に依存させておけば、修正に対してコードを閉じることができるからです。
抽象を使えば、コードを修正しなくても、抽象派生のクラスを新たに追加するだけでモジュールの振る舞いを拡張することができます。

{{<mermaid>}}
classDiagram
Client --> Server
{{< /mermaid >}}

この例ではClientがServerの両方の実装が「具体的に」実装されてしまっています。
ClientクラスはServerクラスを利用しているので、Clientオブジェクト別のServerオブジェクトを利用することに慣ればClientクラスを変更する必要があります。

{{<mermaid>}}
classDiagram
Client --> ClientInterface
Server ..|> ClientInterface
{{< /mermaid >}}

そこで上の図のような設計にしてみるとどうでしょうか。
ClientInterfaceクラスは抽象クラスであり、抽象メンバ関数をいくつか持っています。
Clientクラスは、この抽象クラスを利用することになります。
しかし、実際にClientクラスが利用するのは抽象クラスから派生したServerクラスのオブジェクトになります。
つまり、Clientオブジェクトが新しいServerクラスを利用したくなったら、ClientInterfaceから派生したクラスを別に追加したらいいわけです。
Clientクラスそのものを変更する必要はありません。

Clientの処理内容は抽象インタフェースClientInterfaceを使って記述されています。