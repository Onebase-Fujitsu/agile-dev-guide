---
title: "インターフェース分離の原則(ISP)"
weight: 5
bookToc: true
---

# インターフェース分離の原則(The Interface Segregation Principle)

## インタフェース分離の原則とは

インターフェス分離の原則(ISP)とは **クライアントにクライアントが利用しないメソッドへの依存を強制してはいけない** という原則です。
この原則は「太った」インタフェースをうまくシェイプアップしてくれるものです。
「太った」インタフェースを持つクラスは多数のインタフェースを抱え込んでおり、部分的にしかインタフェース同士が強い関連性を持っていません。
このことは、視点を変えると強い関連性があるインタフェース同士をまとめてグループ化できるということです。
グループ化されたメンバ関数は、それぞれ異なるクライアントにサービスを提供することになります。
なぜなら、クライアントによって必要なメンバ関数は異なるからです。

一般にクライアントは複数のインタフェースを利用しますが、その全てが互いに強い関連性を持っているわけではありません。
インタフェース分離の原則はすべてのインタフェースを１つのクラスに押し込めてしまうのではなく、
関連性を持ったインタフェースはグループ化し、抽象基本クラスとして利用すべきだという主張になります。

## インタフェース汚染

次のようなセキュリティシステムを考えてみます。このシステムにはDoorオブジェクトがあり、それをロックしたり解除したりすることができます。
また、ドアが開いているのか閉じているのかを知ることもできます。

```java
public abstract class Door {
    public abstract void Lock();
    public abstract void Unlock();
    public abstract boolean IsDoorOpen();
}
```

これは抽象クラスなので、クライアントはこのDoorインタフェースを実装しているオブジェクトであればどのようなオブジェクトでも使うことができます。

さて、このインタフェースを実装したクラスの一つであるTimedDoorを見てみましょう。
TimedDoorは長時間ドアが開放されていると警報がなるドアです。この機能を実現するために、TimedDoorはTimerというオブジェクトと通信します。

```java
public abstract class Timer {
    public abstract void Register(int timeout, TimerClient client);
}

public interface TimerClient {
    void Timeout();
}
```
タイムアウトを警告してほしい場合、オブジェクトはTimerのRegisterメソッドを呼び出します。
引数はタイムアウトの時間の長さと、TimerClientになっており、タイムアウトしたときにTimeOut()がコールバックされるようになっています。

ここで、TimerClientクラスがTimedDoorにタイムアウトを通知するにはどうしたらいいでしょうか？

{{< mermaid >}}
classDiagram
Timer --> "0..*" TimerClientInterface
Door ..|> TimerClientInterface
TimedDoor --|> Door
class TimerClientInterface {
    TimeOut() void
}
{{< /mermaid >}}

ここで示す方法では、強制的にTimerClientからDoorを派生させています。
つまり、TimedDoorもTimerClientから派生していることになり、こうすることで、TimedDoorは自分自身を登録し、かつ自分自身がTimeOutのメッセージを受け取ることができるようにしています。

この方法には問題があり、特にDoorクラスがTimerClientに依存していることが問題です。
Doorの派生クラスすべてがTimerを必要とするわけではありません。
実際、最初に記載したDoorの抽象クラスではTimerを必要としておらず、
Timerを必要としないDoorの派生クラスではTimeOutメソッドを使わない（退化させる）ことになり、これは潜在的にリスコフの置換原則に違反しているということになります。

また、Doorの派生クラスを使うアプリケーションでは、たとえTimerを使わなくてもTimerClientの定義を必ずインポートする必要があり、
この方法には「不必要な複雑さ」や「不必要な繰り返し」があることが分かります。

これがインタフェース汚染です。こういった症状はJavaやC++のように静的に片付けされた言語に共通に発生する可能性があります。
この例ではDoorインタフェースが本来不要なメソッドTimeOutで汚染されてしまっているというわけです。
このメソッドをDoorに組み込まなければならない理由はDoorの派生型の一つに恩恵を与えるためでしかありません。
こういった事が行われると、ある派生型が新しいメソッドを必要とする度に、不要なメソッドを基本クラスに追加することになってしまいまいます。
そうすると、基本クラスのインタフェース汚染はますます拡大し、インタフェースが「太る」ことになります。

また、新しいメソッドを基本クラスに追加する度に、派生クラスでも追加されたメソッドを実装しなければならなくなります。
こうした面倒を解消する方法の一つに、そういったメソッドは基本クラスでは単純な実装をしておき、派生クラスでは必要がなければ何もしないという方法があります。
しかし、こうした手法はリスコフの置換原則に違反するため、保守や再利用の際に問題をきたすことになります。

## クライアントの分離とインタフェースの分離