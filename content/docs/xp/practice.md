---
title: "エクストリームプログラミングのプラクティス"
weight: 2
bookToc: true
---

# エクストリームプログラミングのプラクティス

## チームメンバーとしての顧客

顧客と開発者は同じ空間で机を突き合わせて、親密に仕事をするのが望ましいです。
同じ空間で仕事をすることで、お互いに相手の問題を把握することができ、その問題の解決に向けて一緒に取り組めるからです。
これは文字通り物理的な距離の話をしていて、顧客と開発者が同じ部屋で作業するのが最も理想的です。
距離が離れれば離れるほど、顧客をほんとうの意味でのチームに組み込むのが困難になります。

## ユーザーストーリー

プロジェクトの計画を練るためには「仕様要求」の概略をある程度知っていないければいけませんが、詳しく把握しておく必要はありません。
計画をたてる段階では「仕様要求」を実装するための必要な作業量を見積もれる程度の情報で十分です。

もちろん、詳細があることは知っているべきですし、それがどんなものか大まかに把握している必要はありますが、
具体的な詳細まで知っている必要はありません。

個々の仕様要求の詳細はプロジェクトが進むにつれて変化していきます。
特に、まとまった形になったシステムを顧客が受け取れるようになるとそれが顕著になります。
初期のシステムが稼働するのを見ることで、本当の意味で仕様要求に焦点を当てられるようになるからです。
そのため、**システムに組み込むはるか前に仕様要求の具体的な詳細を把握しておくのは早まった行為**と言えます。

## 短期間のリリースサイクル

**XPとスクラムはリリースの考え方が少し異なります。** ここではXPのリリースの考え方を紹介します。
これもちょうど富士通の公開サイトにプロセスを紹介する図があるのでこちらを引用します。

![XPのプロセス](../process.jpg)
画像出典: [アジャイル開発とは（中編）](https://www.fujitsu.com/jp/group/fst/about/resources/featurestories/about-agile-02.html)

XPでは動くソフトウェアを1週間から1ヶ月の短いイテレーションでリリースします。
このイテレーションの間に作られる動くソフトウェアは、出資者の仕様要求の一部を実装したのもで、
イテレーションの終わりにステークホルダーからのフィードバックをを得るためにデモを実施します。

### イテレーションプラン

イテレーションは通常2週間程度でイテレーション毎に小さな機能をいくつか実装して納品します。
しかし、それが最終製品に組み込まれるかどうかは決定していません。
開発者が作成した見積もりをベースに顧客が複数のユーザストーリーを選び、それらが実際に実装されることになります。

開発者は前回のイテレーションでこなした仕事量を参考にして、次回のイテレーションでの仕事量を見積もります。
顧客はその見積もりを超えない範囲で好きな数だけ選択できます。

イテレーションがスタートしたら開発者たちはストリーをタスクレベルに分割し、
技術的にもビジネス的にも最も合理的な順序でそれぞれのタスクを実装していきます。

### リリースプラン

XPチームは次の6回分程度のイテレーションを1つにまとめたプランを作成します。
これを**リリースプラン**といいます。
通常一回のリリースは3ヶ月間隔で設定し、
その間、イテレーションを繰り返し、成果物を一纏めにしてリリースします。

[イテレーションプラン](#イテレーションプラン) のところで「最終製品に組み込まれるかどうかは決定していません。」と書きましたが、
リリースのタイミングでリリースに組み込む内容を決定します。
顧客はストーリーの内容をキャンセルしたり、追加したり、あるいはストーリーの優先順位を変えることができます。

## 受け入れテスト

受け入れテストはE2Eテストとも言われます。
正確にいうと受け入れテストはフェーズであり、E2Eテストは受け入れテストの実施方法です。

ユーザーストーリーの詳細は、顧客が提示する「受け入れテスト」の書式で記述されます。
ストーリーの「受け入れテスト」はそのストーリの実装直前か、実装と並行して作られます。
通常、「受け入れテスト」は自動的に繰り返し実行できるようある種のスクリプト言語で書かれ、
受け入れテストを自動的に繰り返し行うことで、システムが顧客の要求どおりに動かくをチェックできます。

受け入れテストのツールには様々なものがあります。
有名なものだとSelenium、Puppeteer、TestCafe、Cypress.ioあたりでしょうか。
APIテスト周りだとPostmanおよびそのコマンドラインツールであるNewmanや、Karate、Pactなどがあります。
筆者のプロジェクトではWebブラウザ経由のアクセスの動作チェックにTestCafe、
API周りの動作チェックにPostmanとNewmanを採用しました。
これはツールによって得手不得手があったりするので、プロジェクトやアプリの特性に合わせて選択すると良いでしょう。

また、**「受け入れテスト」のスクリプトはシステムと共に成長し、進化していく**ことになります。
新しいイテレーションが始まり機能が追加されたとき、それまでの「受け入れテスト」に追加する形でスクリプトを追加していきます。
つまり、受け入れテストはリグレッションテストも兼ねています。

## ペアプログラミング

ペアプログラミングは2人一組でプログラミングを行うというものです。
2人で1台のコンピュータを使って共同作業をしてコーディングを行っていきます。
ペアの片方がコードを入力し、もうひとりはコードにタイプミスがないかをチェックしたり、エラーや改良点がないかどうかを探し出したりする役割を担います。
ペアがお互いに強く干渉し、検討をす進めながら作業を進め、ソフトウェアを記述するという行為に全身全霊を注ぎます。

ペアの役割は頻繁に交代します。コード入力担当者が疲れたり行き詰まったりすると、
相方がもっとこうしたらいいんじゃないかとアドバイスを出したり、キーボードを奪って相方に変わってコード入力をしたりします。

**ペアプログラミングではペアの組み合わせを毎日変えます。**
そうすると、一人のプログラマがイテレーションで組み込もうとする機能全てに関わることになります。
特定の一人にシステムの知識が偏るということがなくなります。
プロジェクトが抱えるリスク指標の１つに「バス係数」というものがあります。
これは「何人がバスに惹かれるとそのプロジェクトが成り立たなくなるか」を示したものです。
特定の機能の仕様を把握しているメンバーが1人しかいない場合、そのプロジェクトのバス係数は1となります。
そのプロジェクトメンバが何らかの原因でプロジェクトから抜けるとそのプロジェクトは破綻してしまいます。
そうした自体を防ぐために、ペアを必ず入れ替えてプロジェクトの知識やノウハウを分散したほうがいいでしょう。

また、ペアプログラミングは有識者が他のメンバに**ティーチング**をするという側面もあり、
ペアプログラミングを繰り返すことで開発チーム全体の開発スキルの底上げが期待できます。

## テストファーストの開発

テスト駆動開発(Test-Driven Development、以下TDD)についてはテストの章で詳しく書きますので、ここでは概要だけ説明します。

テスト駆動開発では**まず実装しようとする機能の振る舞いをユニットテストとして実装します。**
ユニットテストを実装した段階では機能はまだ実装されていないため、テストは失敗します。
そして、**失敗したテストをパスさせる目的で機能を実装する**という流れで開発していきます。

テストコードが僅かに実装コードを先導しながら、ほとんど同時に進化していきます。
その結果、完璧なテストコードがプロダクトのコード共に形成されることになります。

仕様変更で実装コードに少しでも変更を加えたら、テストを細かく再実行して正常に動作するか確認します。
**ユニットテストがリグレッションテストの役割を担い、変更によって思わぬ障害が起きていないか確認できる**ようになります。
また、完璧なテストコードがあるおかげで [リファクタリング](#リファクタリング) ができるようになるというメリットもあります。

なぜ、テストから先に書くのかと言われると、完璧なテストコードを書くためです。
「あとからでもいいのでは？」と思われるかもしれませんが、あとからの実装では、
テストコードの抜け漏れが起きる可能性が高くなります。
そうすると、後述のリファクタリングを行ったときに思わぬバグを作り込んでしまう可能性があります。
**テストを最初に実装する、そしてそのテストを充足するコードのみを書く。このプロセスがとても大事なのです。**

## 共同所有権

## 継続的なインテグレーション(統合)

## 持続可能なペース

## オープンワークスペース

## シンプルな設計

### 最もシンプルな実装を考える

### 「後で必要になる」は不要

### 同じことを2度しない

## リファクタリング

## メタファー

